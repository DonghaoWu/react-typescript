## 常用的 react typeScript 情况：

1. 子组件接受 props，对相关的 props 定义 types。

```ts
interface ChildProps {
  color: string;
  handleClick: () => void;
}
```

2. 子组件作为一个 funcitonal component 接受来自父组件的 props。

```ts
export const ChildAsFC: React.FC<ChildProps> = ({ color, handleClick }) => {
  return <div></div>;
};
```

3. 定义以 event 为参数的 handleChange。

```ts
const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  setName(event.target.value);
};
```

4. useState 定义初始 state 时出现的情况：

```ts
const [name, setName] = useState('');
const [user, setUser] = useState<{ name: string; age: number } | undefined>();
```

5. useRef 的使用：

- 一下这个例子使用 useRef 不好。

```ts
import { useRef } from 'react';

const inputRef = useRef<HTMLInputElement | null>(null);

<input ref={inputRef} value={name} onChange={(e) => setName(e.target.value)} />;
```

6. interface 之间的嵌套使用：

```ts
interface User {
  name: string;
  age: number;
}

interface UserSearchProps {
  users: User[];
}

interface UserSearchState {
  name: string;
  user: User | undefined;
}
```

7. class component 同时应用 props 和 state 定义的 type。

```ts
class UserSearchCC extends Component<UserSearchProps> {
  state: UserSearchState = {
    name: '',
    user: undefined,
  };

  render() {
    return <div></div>;
  }
}
```

8. 目前已知两种 interface 常见应用：

```ts
// 1
state: UserSearchState = {
  name: '',
  user: undefined,
};

// 2
export const ChildAsFC: React.FC<ChildProps> = ({ color, handleClick }) => {
  return <div></div>;
};

// 3
const [user, setUser] = useState<{ name: string; age: number } | undefined>();
```

---

## Redux 应用中：

1. 定义 initialState 的 type。

```ts
interface RepoState {
  loading: boolean;
  error: string | null;
  data: string[];
}

const initialState = {
  loading: false,
  error: null,
  data: [],
};
```

2. 定义 action 的 type。

```ts
import { ActionType } from '../action-types';

interface SearchReposAction {
  type: ActionType.SEARCH_REPOS;
}

interface SearchReposSuccessAction {
  type: ActionType.SEARCH_REPOS_SUCCESS;
  payload: string[];
}

interface SearchReposErrorAction {
  type: ActionType.SEARCH_REPOS_ERROR;
  payload: string;
}

export type Action =
  | SearchReposAction
  | SearchReposSuccessAction
  | SearchReposErrorAction;
```

3. 定义 action creator 中 dispatch 的类型。

```ts
import axios from 'axios';
import { Dispatch } from 'redux';
import { ActionType } from '../action-types';
import { Action } from '../actions';

export const searchRepos = (terms: string) => {
  return async (dispatch: Dispatch<Action>) => {
    dispatch({
      type: ActionType.SEARCH_REPOS,
    });
  };
};
```

4. 使用 useSelector

```ts
// reducer/index.js
import { combineReducers } from 'redux';
import reposReducer from './reposReducer';

const reducers = combineReducers({
  repos: reposReducer,
});

export default reducers;
export type RootState = ReturnType<typeof reducers>;

// hooks/useTypedSelector.js
import { useSelector, TypedUseSelectorHook } from 'react-redux';
import { RootState } from '../redux';

const useTypedSelector: TypedUseSelectorHook<RootState> = useSelector;

// RepositoriesList.jsx
const RepositoriesList: React.FC = () => {
  const { data, error, loading } = useTypedSelector((state) => state.repos);

  return <div></div>;
};
```

5. 使用 useDispatch

```ts
import { useDispatch } from 'react-redux';
import { bindActionCreators } from 'redux';
import { actionCreators } from '../redux';

const useActions = () => {
  const dispatch = useDispatch();

  return bindActionCreators(actionCreators, dispatch);
};

// RepositoriesList.jsx
const RepositoriesList: React.FC = () => {
  const { searchRepos } = useActions();

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    searchRepos(term);
  };

  return <div></div>;
};
```
